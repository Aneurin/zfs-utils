#!/bin/bash

# Configuration:
#
# For each dataset to synchronise, set the property "zfs-mirror:dest" locally on
# that dataset, to values of the form "hostname:pool[,hostname:pool...]"
#
# The script will set the property "zfs-mirror:latest" on the root dataset; this
# shouldn't be manually changed.

set -o nounset
set -e

# Ugly perhaps, but this is the simplest way not to have to worry about $PATH on
# different systems
PATH=/usr/gnu/bin:/usr/local/bin:/opt/bin:/sbin:/usr/sbin:/bin:/usr/bin:$PATH

LOCAL_ZFS=zfs
LOCAL_ZPOOL=zpool
GREP=grep
HEAD=head
SSH=ssh
PV=pv

VERBOSE=0
REALLY=1
PROGRESS=0
BWLIMIT=""
KEEP_DEST=10
KEEP_SRC=2
ZFS_SEND_DEDUP=""
ZFS_VERBOSE=""
LOG_TO_STDERR=false
COLOUR="auto"
COMPRESS=false
XZSEND=""
XZRECV=""
USE_TEMP_FILE=false
AGE_REPORTING=false
AGE_WARNING_SECONDS=$((60 * 60 * 24))

PROPERTY_PREFIX=zfs-mirror
SNAPSHOT_PREFIX=zfs-mirror

ERR_SRC_POOL_MISSING=64   # Source pool not given or not found
ERR_DEST_POOL_MISSING=65  # Destination pool not found
ERR_NO_SOURCES_DEFINED=66 # No source filesystems are configured for the given destination
ERR_SRC_SNAP_MISSING=67   # The source filesystem doesn't have the counterpart to the destination's latest snapshot
ERR_COULDNT_SEND=68       # There was a problem synchronising the snapshot from the source to the destination

DEPTH=0 # For indenting trace output

function out {
    if $LOG_TO_STDERR; then
        cat >&2
    else
        logger -t zfs-mirror\[$$\]
    fi
}

function warn {
    echo -e "[$COL_YELLOW""Warn: $COL_END]" "$*" | out
}

function error {
    echo -e "[$COL_RED""Error:$COL_END]" "$1" | out
    local status=${2:-1}
    exit $status
}

function trace {
    if [[ $VERBOSE -ge 3 ]]; then
        printf "[$COL_GREY""Trace:$COL_END] $COL_GREY""[$($DATE)]$COL_END%*s%s\n" $((DEPTH * 4)) " " "$*" | out
    fi
}

function log {
    if [[ $VERBOSE -ge 1 ]]; then
        echo -e "[$COL_GREEN""Info: $COL_END]" "$*" | out
    fi
}

function logv {
    if [[ $VERBOSE -ge 2 ]]; then
        echo "[Debug:]" "$*" | out
    fi
}

function do_conditionally {
    trace $FUNCNAME $@

    if [[ $REALLY == 1 ]]; then
        log "Running: $@"
        eval $@
    else
        log "Would run: $@"
    fi
}

function duration {
    trace $FUNCNAME $@
    # Second argument signifies that we are being called recursively, and
    # should not output anything if the remainder is 0.
    if [[ $1 -eq 0 ]] && ${2:-false}; then
        return 0
    elif ${2:-false}; then
        echo -n " "
    fi
    if [[ $1 -le 60 ]]; then
        echo -n "${1}s"
    elif [[ $1 -le 3600 ]]; then
        m=$(($1 / 60))
        echo -n "${m}m$(duration $(($1 - ($m * 60) )) true)"
    elif [[ $1 -le $((3600 * 24)) ]]; then
        h=$(($1 / 3600))
        echo -n "${h}h$(duration $(($1 - ($h * 3600) )) true)"
    else
        d=$(($1 / (3600 * 24) ))
        echo -n "${d}d$(duration $(($1 - ($d * 3600 * 24) )) true)"
    fi
}

function human_readable_size {
    trace $FUNCNAME $@
    if [[ $1 -eq 0 ]]; then
        echo "0B"
    elif [[ $1 -lt 1024 ]]; then
        echo "${1}B"
    elif [[ $1 -lt $((1024 * 1024)) ]]; then
        echo "$(($1 / 1024))kB"
    elif [[ $1 -lt $((1024 * 1024 * 1024)) ]]; then
        echo "$(($1 / (1024 * 1024) ))MB"
    else
        echo $(echo "$1  $((1024 * 1024 * 1024))" | awk '{printf "%.2fGB", $1/$2}')
    fi
}

function split {
    trace $FUNCNAME $@
    echo $@ | sed 's/,/ /g'
}

function pool_lockfile {
    trace $FUNCNAME $@
    echo $LOCK_PATH/zfs-mirror-$1.lock
}

function get_lock {
    trace $FUNCNAME $@
    logv "Trying to take lock: $1"
    ( set -o noclobber; echo "$$" > "$1") 2> /dev/null
    return $?
}

function have_lock {
    trace $FUNCNAME $@
    [ -f $1 ] && [ $(cat $1) = $$ ]
    return $?
}

function release_lock {
    trace $FUNCNAME $@
    : $((DEPTH++))
    logv "Releasing lock $1"
    if have_lock $1; then
        rm -f $1
    fi
    : $((DEPTH--))
    return 0
}

function cleanup {
    trace $FUNCNAME $@
    : $((DEPTH++))
    release_lock $SRC_LOCKFILE
    release_lock $DEST_LOCKFILE
    : $((DEPTH--))
    return $1
}

function zfs_supports_multiple_snapshots {
    trace $FUNCNAME $@
    # Does the usage note for zfs snapshot include '...' at the end.
    $LOCAL_ZFS snapshot 2>&1 | $GREP -q -e '\.\.\.$'
    return $?
}

function get_source_filesystems {
    trace $FUNCNAME $@
    local dest=${1:-""}
    for fs in $($LOCAL_ZFS list -rH -o name $SRC); do
        if $LOCAL_ZFS get -Hp -o value -s local $PROPERTY_PREFIX:dest $fs | $GREP -q ""$dest; then
            logv "$fs configured as sync source"
            echo $fs
        fi
    done
}

function dataset_exists {
    trace $FUNCNAME $@
    local host=$(echo $1 | cut -d: -f1)
    local dataset=$(echo $1 | cut -d: -f2)
    logv "Checking $dataset exists"
    if [[ $host == "localhost" ]]; then
        local zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    $zfs list $dataset >/dev/null 2>&1
    return $?
}

function latest_snapshot {
    trace $FUNCNAME $@
    local host=$(echo $1 | cut -d: -f1)
    local dataset=$(echo $1 | cut -d: -f2)
    if [[ $host == "localhost" ]]; then
        local zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    local latest=$($zfs list -H -d 1 -r -o name -s name -t snapshot $dataset 2>  /dev/null | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n | tail -n 1)
    echo -n ${latest:-0}
    logv "Latest snapshot of $1: ${latest:-0}"
}

function snapshot_created {
    trace $FUNCNAME $@
    local host=$(echo $1 | cut -d: -f1)
    local snapshot=$(echo $1 | cut -d: -f2)
    if [[ $host == "localhost" ]]; then
        local zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    local creation=$($zfs get -H -p -o value creation $snapshot 2>  /dev/null)
    case $creation in
        ''|*[!0-9]*) warn "Couldn't get creation time for $snapshot on $host (got $creation); returning 0"
        creation=0
        ;;
    esac
    echo -n ${creation}
    logv "Creation time of $1: ${creation}"
}

function get_dataset_destinations {
    trace $FUNCNAME $@
    split $($LOCAL_ZFS get -Hp -o value -s local $PROPERTY_PREFIX:dest $1)
}

function host_has_cmd {
    trace $FUNCNAME $@
    local dest_host=$(echo $1 | cut -d: -f1)
    if [[ $dest_host == "localhost" ]]; then
        $2 > /dev/null 2>&1
    else
        logv "Connecting to remote host '$dest_host'"
        $SSH $dest_host $2 > /dev/null 2>&1
    fi
    return $?
}

function get_pv_cmd {
    trace $FUNCNAME $@
    # Expects args of the form "dataset@snapshot" or "-i @snapshot1 dataset@snapshot2"
    local pv=""
    if [[ $REALLY == 1 ]] && [[ $PROGRESS == 1 ]]; then
        # Invoking zfs send to get the transfer size can take a few seconds, but
        # in practice it seems to warm some cache so the actual send take a few
        # seconds less, balancing it out.
        local size=$($LOCAL_ZFS send -nP $@ 2>&1 | tail -n 1|cut -f2)
        log "$(human_readable_size $size) to send (estimated)"
        # Don't bother showing progress bar for < 5MB. The inaccuracy in the
        # estimate will probably be greater than the actual value.
        if [[ $size -ge 5*1024*1024 ]]; then
            pv="pv -s $size |"
        else
            logv "Not showing progress for transfer estimated as less than 5MB"
        fi
    fi
    echo $pv
}

function zfs_try_send_incr {
    # $1 source dataset
    # $2 source snapshot number
    # $3 destination snapshot number
    # $4 destination zfs command
    # $5 destination pool
    trace $FUNCNAME $@
    local pv=$(get_pv_cmd -i @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3)
    local error_msg=$(do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP -i @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 | $pv $4 receive $ZFS_VERBOSE -ud $5 2>&1 || true")
    error_msg=${error_msg%%\\r}
    if [[ $error_msg != "" ]]; then
        if [[ $error_msg == "cannot receive incremental stream: invalid backup stream" ]]; then
            log "Error sending @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 ($error_msg). Retrying:"
            error_msg=$(do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP -i @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 | $pv $4 receive $ZFS_VERBOSE -ud $5 2>&1 || true")
            if [[ $error_msg != "" ]]; then
                warn "Error sending @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 ($error_msg)"
            else
                log "Retry successful"
            fi
        else
            warn "Error sending @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 ($error_msg)"
        fi
    fi
    echo $error_msg
}

function zfs_send_incr {
    trace $FUNCNAME $@
    : $((DEPTH++))
#$fs $DEST $old_snap $new_snap
    local dest_host=$(echo $2 | cut -d: -f1)
    local dest_pool=$(echo $2 | cut -d: -f2)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$dest_host'"
        if $USE_TEMP_FILE; then
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host __zfs_receive_tmpfile \"$XZRECV zfs"
            dest_pool=$dest_pool'"'
        else
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host $XZRECV zfs"
        fi
    fi
    local error_msg=$(zfs_try_send_incr $1 $3 $4 "$dest_zfs" "$dest_pool")
    if [[ $error_msg != "" ]]; then
        if [[ $error_msg == "cannot receive incremental stream: invalid backup stream" ]] && [[ $4 -gt $(( $3 + 1 )) ]]; then
            warn "Attempting to send intervening snapshots one-by-one:"
            local intervening_snapshots=$($LOCAL_ZFS list -H -d 1 -r -o name -s name -t snapshot $1 2> /dev/null | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n)
            local prev=$3
            for snapshot in $intervening_snapshots; do
                if [[ $snapshot -le $prev ]]; then
                    continue
                fi
                error_msg=$(zfs_try_send_incr $1 $prev $snapshot "$dest_zfs" "$dest_pool")
                if [[ $error_msg != "" ]]; then
                    break
                fi
                prev=$snapshot
            done
        fi
    fi
    : $((DEPTH--))
    return 0
}

function zfs_send_new {
    trace $FUNCNAME $@
    : $((DEPTH++))
#$fs $DEST $new_snap
    local dest_host=$(echo $2 | cut -d: -f1)
    local dest_pool=$(echo $2 | cut -d: -f2)
    local destfs=$(echo -n "$1" | sed -e "s/^$SRC/$dest_pool/")
    local pv=$(get_pv_cmd $1@"$SNAPSHOT_PREFIX"_$3)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
        local dest_zfs_cmd=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$dest_host'"
        if $USE_TEMP_FILE; then
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host __zfs_receive_tmpfile \"$XZRECV zfs"
            dest_pool=$dest_pool'"'
        else
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host $XZRECV zfs"
        fi
        local dest_zfs_cmd="$SSH $dest_host zfs"
    fi
    do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP $1@"$SNAPSHOT_PREFIX"_$3 | $pv $dest_zfs receive -ud $dest_pool"
    do_conditionally "$dest_zfs_cmd set readonly=on $destfs"
    : $((DEPTH--))
    return 0
}

function expire_src_snaps {
    trace $FUNCNAME $@
    : $((DEPTH++))
    # NB: if a dest has been set for a dataset but has not completed even the
    # initial send, no snapshots will be destroyed as there's no way to know for
    # certain if a given snapshot is currently being sent by another instance of
    # the script.
    logv "Expiring old snapshots on $SRC"
    if [[ $(echo -e "foo\nbar"|$HEAD -n -1 2>/dev/null) != "foo" ]]; then
        warn "'$HEAD' doesn't support '-n -XX'; not expiring any snapshots on $1"
        return
    fi
    if [[ $KEEP_SRC -gt 1 ]]; then
        logv "Not considering the $KEEP_SRC most recent snapshots of each dataset for deletion"
    fi
    local latest_snap_num=$($LOCAL_ZFS get -pH -o value $PROPERTY_PREFIX:latest $SRC)
    for fs in $@; do
        local latest_needed_snap_num=$latest_snap_num
        for dest in $(get_dataset_destinations $fs); do
            local destfs=$(echo -n "$fs" | sed -e "s/^$SRC/$dest/")
            local latest_snap_on_dest=$(latest_snapshot $destfs)
            if [[ $latest_snap_on_dest == "0" ]]; then
                warn "Can't find any snapshots of $fs on $dest; either this dataset has never been synchronised, or there was a connection problem. Not expiring any snapshots."
            fi
            if [[ $latest_snap_on_dest -lt $latest_needed_snap_num ]]; then
                latest_needed_snap_num=$latest_snap_on_dest
            fi
        done
        for snap_num in $($LOCAL_ZFS list -H -d 1 -r -o name -s name -t snapshot $fs | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n | $HEAD -n -$KEEP_SRC); do
            if [[ $snap_num -lt $latest_needed_snap_num ]]; then
                logv "Snapshot unneeded: $fs@"$SNAPSHOT_PREFIX"_$snap_num"
                do_conditionally "$LOCAL_ZFS destroy $ZFS_VERBOSE $fs@"$SNAPSHOT_PREFIX"_$snap_num"
            else
                logv "Snapshot needed: $fs@"$SNAPSHOT_PREFIX"_$snap_num"
            fi
        done
    done
    : $((DEPTH--))
    return 0
}

function expire_dest_snaps {
    trace $FUNCNAME $@
    : $((DEPTH++))
    # $DEST $source_filesystems
    logv "Expiring old snapshots on $1"
    if [[ $(echo -e "foo\nbar"|$HEAD -n -1 2>/dev/null) != "foo" ]]; then
        warn "'$HEAD' doesn't support '-n -XX'; not expiring any snapshots on $1"
        return
    fi
    local dest_host=$(echo $1 | cut -d: -f1)
    local dest_pool=$(echo $1 | cut -d: -f2)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
        local dest_zpool=$LOCAL_ZPOOL
    else
        logv "Connecting to remote host '$dest_host'"
        local dest_zfs="$SSH $dest_host zfs"
        local dest_zpool="$SSH $dest_host zpool"
    fi
    shift
    for srcfs in $@; do
        destfs=$(echo -n "$srcfs" | sed -e "s/$SRC/$dest_pool/")
        logv "Expiring snapshots on $dest_host:$destfs"
        for snap_num in $($dest_zfs list -H -d 1 -r -o name -s name -t snapshot $destfs 2>  /dev/null | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n | $HEAD -n -$KEEP_DEST); do
            do_conditionally "$dest_zfs destroy $ZFS_VERBOSE $destfs@"$SNAPSHOT_PREFIX"_$snap_num"
        done
    done
    local threshold=95
    local cap=$($dest_zpool list -H -o capacity $dest_pool)
    if [[ ! $? ]]; then
        # Strictly this check isn't necessary, but the previous check for this
        # pool's existence used 'zfs' rather than 'zpool', so this serves as a
        # sanity check that 'zpool' is available.
        warn "Couldn't find pool ${dest_host}:$dest_pool"
    elif [[ $(echo $cap | cut -d% -f1) -gt $threshold ]]; then
        warn "Destination capacity over $threshold% ($cap) after snapshot expiration"
    fi
    : $((DEPTH--))
    return 0
}

function age_report {
    trace $FUNCNAME $@
    # $DEST
    log "Checking for snapshots on $1 older than $(duration $AGE_WARNING_SECONDS):"
    [ -f $DEST_LOCKFILE ] && log "There appears to be a synchronisation to $1 currently in progress"
    if ! which $DATE_COMMAND > /dev/null 2>&1; then
        error "'date' not found; can't check snapshot ages"
    fi
    logv "Source filesystems:"
    local source_filesystems=$(get_source_filesystems $1)
    local max_name_len=0
    for fs in $source_filesystems; do
        if [[ ${#fs} -gt $max_name_len ]]; then
            max_name_len=${#fs}
        fi
    done
    for fs in $source_filesystems; do
        local pad_len=$((max_name_len - ${#fs}))
        local padding=$(printf "%*.s" $pad_len)
        local latest_snap_num=$(latest_snapshot $(echo -n "$fs" | sed -e "s/^$SRC/$1/"))
        local latest_snap=$SNAPSHOT_PREFIX"_"$latest_snap_num
        if [[ $latest_snap_num -le 0 ]]; then
            warn "Can't find any snapshots of $fs on $1; either this dataset has never been synchronised, or there was a connection problem"
            created=0
        else
            created=$(snapshot_created $(echo -n "$fs" | sed -e "s/^$SRC/$1/")@$latest_snap)
        fi
        local time_now=$($DATE_COMMAND +%s)
        local age=$(($time_now - $created))
        if [[ $age -gt $AGE_WARNING_SECONDS ]]; then
            warn "Latest snapshot of $fs on $1:$padding $latest_snap, created $($DATE_COMMAND -d @$created) ($(duration $age) old)"
        else
            log "Latest snapshot of $fs on $1:$padding $latest_snap, created $($DATE_COMMAND -d @$created) ($(duration $age) old)"
        fi
    done
}

function mirror {
    trace $FUNCNAME $@
    local src=$1
    local dest=$2
    if get_lock $SRC_LOCKFILE; then
        # It's probably not worth waiting for the per-destination lock, since it
        # could be held for a long time (ie. there's a sync in progress)
        if get_lock $DEST_LOCKFILE; then
            local old_snap=$($LOCAL_ZFS get -pH -o value $PROPERTY_PREFIX:latest $src)
            local new_snap=$(($old_snap + 1))

            # define what snapshots we want to create
            logv "Source filesystems:"
            local source_filesystems=$(get_source_filesystems $dest)
            local new_snapshots=""
            for fs in $source_filesystems; do
                new_snapshots+=" $fs@"$SNAPSHOT_PREFIX"_$new_snap"
            done

            # Second task: create new snapshots
            if [[ $source_filesystems != "" ]]; then
                do_conditionally "$LOCAL_ZFS set $PROPERTY_PREFIX:latest=$new_snap $src"
                if zfs_supports_multiple_snapshots; then
                    do_conditionally "$LOCAL_ZFS snapshot $new_snapshots"
                else
                    warn "This version of zfs does not support making multiple snapshots in a single invocation; snapshot creation will not be atomic."
                    for snap in $new_snapshots; do
                        do_conditionally "$LOCAL_ZFS snapshot $snap"
                    done
                fi
            else
                error "No source filesytems defined for destination $dest" $ERR_NO_SOURCES_DEFINED
            fi
            release_lock $SRC_LOCKFILE

            # Third task: sync new snapshots
            if $COMPRESS && host_has_cmd localhost "xz --version" && host_has_cmd $dest "xzcat --version"; then
                XZSEND="xz |"
                XZRECV="xzcat \|"
            fi
            for fs in $source_filesystems; do
                old_snap=$(latest_snapshot $(echo -n "$fs" | sed -e "s/^$src/$dest/"))
                if [[ $old_snap -gt 0 ]]; then
                    if ! dataset_exists localhost:$fs@"$SNAPSHOT_PREFIX"_$old_snap; then
                        error "Snapshot $fs@"$SNAPSHOT_PREFIX"_$old_snap missing from $src" $ERR_SRC_SNAP_MISSING
                    fi
                    zfs_send_incr $fs $dest $old_snap $new_snap
                else
                    zfs_send_new $fs $dest $new_snap
                fi
                if [[ ! $? ]]; then
                    error "Failed to send $fs@$new_snap to $dest; giving up" $ERR_COULDNT_SEND
                fi
            done
            # Fourth task: expire unneeded snapshots on source
            if get_lock $SRC_LOCKFILE; then
                # It's not critical that this done now - for one thing, in all
                # probability whatever process is holding the lock will do this
                # snapshot expiration anyway - so don't bother waiting for it to
                # become available.
                expire_src_snaps $source_filesystems
            fi
            # Fifth task: expire unwanted snapshots on dest
            expire_dest_snaps $dest $source_filesystems
        else
            log "Couldn't get lock for $dest; giving up"
            exit 1
        fi
    else
        log "Couldn't get lock for $src after $WAITTIME seconds; giving up"
        exit 1
    fi
}

if [[ -t 2 ]]; then
    # stderr is a terminal
    LOG_TO_STDERR=true
fi

while getopts "b:c:k:nprtvDo:z" opt; do
    case $opt in
        b)
            if [[ -x $(which $PV) ]]; then
                BWLIMIT="$PV -qL ${OPTARG}k |"
            else
                PV_NOT_FOUND=true
            fi
            ;;
        c)
            COLOUR=$OPTARG
            ;;
        k)
            # Sanity check: don't allow this to be set to less than 1
            if [[ $OPTARG -ge 1 ]]; then
                KEEP_DEST=$OPTARG
            else
                KEEP_DEST=1
            fi
            ;;
        n)
            REALLY=0
            ;;
        p)
            if [[ -x $(which $PV) ]]; then
                PROGRESS=1
            else
                PV_NOT_FOUND=true
                PROGRESS=0
            fi
            ;;
        r)
            AGE_REPORTING=true
            ;;
        t)
            USE_TEMP_FILE=true
            ;;
        v)
            : $((VERBOSE++))
            ;;
        D)
            ZFS_SEND_DEDUP="-D"
            ;;
        o)
            case $OPTARG in
                auto)
                    ;;
                syslog)
                    LOG_TO_STDERR=false
                    ;;
                tty)
                    LOG_TO_STDERR=true
                    ;;
                *)
                    INVALID_OUTPUT_DEST=true
                    ;;
            esac
            ;;
        z)
            COMPRESS=true
            ;;
    esac
done
shift $((OPTIND - 1))

case $COLOUR in
    never)
        COLOUR=false
        ;;
    always)
        COLOUR=true
        ;;
    auto)
        if $LOG_TO_STDERR && [[ -t 2 ]]; then
            COLOUR=true
        else
            COLOUR=false
        fi
        ;;
    *)
        INVALID_COLOUR=true
        if $LOG_TO_STDERR && [[ -t 2 ]]; then
            COLOUR=true
        else
            COLOUR=false
        fi
        ;;
esac

if $COLOUR; then
    COL_GREEN="\e[32m"
    COL_GREY="\e[1;30m"
    COL_YELLOW="\e[1;33m"
    COL_RED="\e[31m"
    COL_END="\e[0m"
else
    COL_GREEN=""
    COL_GREY=""
    COL_YELLOW=""
    COL_RED=""
    COL_END=""
fi

if [[ -n ${PV_NOT_FOUND+x} ]]; then
    warn "Progress display and bandwidth limiting require 'pv', which was not found in \$PATH"
fi

if [[ -n ${INVALID_COLOUR+x} ]]; then
    warn "Argument to -c must be 'auto', 'never', or 'always'. Using auto."
fi

if [[ -n ${INVALID_OUTPUT_DEST+x} ]]; then
    warn "Argument to -o must be 'auto', 'syslog', or 'tty'. Using auto."
fi
for command in $LOCAL_ZFS $LOCAL_ZPOOL $GREP; do
    if [[ ! -x $(which $command) ]]; then
        error "'$command' not found"
    fi
done

if [[ $# -eq 0 ]]; then
    error "You must specify a source pool" $ERR_SRC_POOL_MISSING
fi
SRC=$1
DEST=${2:-'localhost:backup'}

if [[ $VERBOSE -ge 4 ]]; then
    ZFS_VERBOSE="-v"
fi

if [[ $(id -u) -eq 0 ]]; then
    LOCK_PATH=/var/run
else
    LOCK_PATH=$HOME
fi

if [[ $VERBOSE -ge 3 ]] || $AGE_REPORTING; then
    if [[ -e /usr/gnu/bin/date ]]; then
        DATE_COMMAND="/usr/gnu/bin/date"
    else
        DATE_COMMAND="date"
    fi
    if ! which $DATE_COMMAND > /dev/null 2>&1; then
        warn "'date' not found; trace output will lack timestamps"
        DATE=""
    elif ! $DATE_COMMAND --rfc-3339=ns > /dev/null 2>&1; then
        warn "'date' doesn't support '--rfc-3339'; trace timestamps will only have second precision"
        DATE="$DATE_COMMAND +%Y/%m/%d/%H.%M.%S"
    else
        DATE="$DATE_COMMAND --rfc-3339=ns"
    fi
fi

trap 'cleanup $?' INT TERM EXIT

if ! dataset_exists localhost:$SRC; then
    error "Couldn't find source pool '$SRC'" $ERR_SRC_POOL_MISSING
fi
if [[ $(echo $DEST | cut -d: -f1) != "localhost" ]] && [[ ! -x $(which $SSH) ]]; then
    error "'$SSH' not found"
fi
if ! dataset_exists $DEST; then
    error "Couldn't find pool $DEST" $ERR_DEST_POOL_MISSING
fi

SRC_LOCKFILE=$(pool_lockfile $SRC)
DEST_LOCKFILE=$(pool_lockfile $DEST)

# It's worth waiting for the source lock to become available, as it's only held
# while creating and expiring snapshots, which typically doesn't take very long.
WAITTIME=0
while [[ -e "$SRC_LOCKFILE" ]] && [[ $WAITTIME -lt 60 ]]; do
    log "Couldn't get lock for $SRC (after $WAITTIME seconds); waiting 10 seconds"
    : $((WAITTIME += 10))
    sleep 10
done

if $AGE_REPORTING; then
    age_report $DEST
else
    mirror $SRC $DEST
fi
