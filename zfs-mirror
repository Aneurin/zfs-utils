#!/bin/bash

# Configuration:
#
# For each dataset to synchronise, set the property "zfs-mirror:dest" locally on
# that dataset, to values of the form "hostname:pool[,hostname:pool...]"
# (With '-r', the inherited value is used, so it needn't be set locally on each
# dataset in tha case.)
#
# The script will set the property "zfs-mirror:latest" on the root dataset; this
# shouldn't be manually changed.

set -o nounset
set -e

shopt -s extglob

# Ugly perhaps, but this is the simplest way not to have to worry about $PATH on
# different systems
PATH=/usr/gnu/bin:/usr/local/bin:/opt/bin:/sbin:/usr/sbin:/bin:/usr/bin:$PATH

LOCAL_ZFS=zfs
LOCAL_ZPOOL=zpool
GREP=grep
HEAD=head
SSH=ssh
PV=pv

VERBOSE=0
REALLY=true
PROGRESS=false
BWLIMIT=""
KEEP_DEST=10
KEEP_SRC=2
ZFS_SEND_DEDUP=""
ZFS_VERBOSE=""
LOG_TO_STDERR=false
COLOUR="auto"
COMPRESS=false
XZSEND=""
XZRECV=""
USE_TEMP_FILE=false
AGE_REPORTING=false
AGE_WARNING_SECONDS_DEFAULT=$((60 * 60 * 24))
LOG_SIZES_TO_FILE=false
WAIT_FOR_LOCK=false
PROPERTY_SOURCE_LOCAL="-s local"

PROPERTY_PREFIX=zfs-mirror
SNAPSHOT_PREFIX=zfs-mirror

ERR_SRC_POOL_MISSING=64   # Source pool not given or not found
ERR_DEST_POOL_MISSING=65  # Destination pool not found
ERR_NO_SOURCES_DEFINED=66 # No source filesystems are configured for the given destination
ERR_SRC_SNAP_MISSING=67   # The source filesystem doesn't have the counterpart to the destination's latest snapshot
ERR_COULDNT_SEND=68       # There was a problem synchronising the snapshot from the source to the destination
ERR_INVALID_ARGUMENT=69   # Unknown command line argument given

DEPTH=0 # For indenting trace output

function out {
    if $LOG_TO_STDERR; then
        cat >&2
    else
        logger -t zfs-mirror\[$$\]
    fi
}

function warn {
    echo -e "[${COL_YELLOW}Warn: $COL_END]" "$*" | out
}

function error {
    local message="$1"
    local status=${2:-1}
    echo -e "[${COL_RED}Error:$COL_END]" "$message" | out
    exit $status
}

function trace {
    if [[ $VERBOSE -ge 3 ]]; then
        printf "[${COL_GREY}Trace:$COL_END] ${COL_GREY}[$($DATE)]$COL_END%*s%s\n" $((DEPTH * 4)) " " "$*" | out
    fi
}

function log {
    if [[ $VERBOSE -ge 1 ]]; then
        echo -e "[${COL_GREEN}Info: $COL_END]" "$*" | out
    fi
}

function logv {
    if [[ $VERBOSE -ge 2 ]]; then
        echo "[Debug:]" "$*" | out
    fi
}

function do_conditionally {
    trace $FUNCNAME $@

    if $REALLY; then
        log "Running: $@"
        eval $@
    else
        log "Would run: $@"
    fi
}

function duration {
    trace $FUNCNAME $@
    local seconds="$1"
    local recursive=${2:-false}
    # Second argument signifies that we are being called recursively, and
    # should not output anything if the remainder is 0.
    if [[ $seconds -eq 0 ]] && $recursive; then
        return 0
    elif $recursive; then
        echo -n " "
    fi
    if [[ $seconds -le 60 ]]; then
        echo -n "${seconds}s"
    elif [[ $seconds -le 3600 ]]; then
        m=$(($seconds / 60))
        echo -n "${m}m$(duration $(($seconds - ($m * 60) )) true)"
    elif [[ $seconds -le $((3600 * 24)) ]]; then
        h=$(($seconds / 3600))
        echo -n "${h}h$(duration $(($seconds - ($h * 3600) )) true)"
    else
        d=$(($seconds / (3600 * 24) ))
        echo -n "${d}d$(duration $(($seconds - ($d * 3600 * 24) )) true)"
    fi
}

function parse_duration {
    trace $FUNCNAME $@
    case $1 in
        +([0-9]))
            echo $1
            return 0
            ;;
        +([0-9])[dhms])
            local value=${1%[dhms]}
            local units=${1:(-1)}
            case $units in
                d)
                    echo $((value * 24 * 60 * 60))
                    ;;
                h)
                    echo $((value * 60 * 60))
                    ;;
                m)
                    echo $((value * 60))
                    ;;
                s)
                    echo $value
                    ;;
            esac
            ;;
        *)
            warn "Argument to -a must be a number, optionally suffixed with d, h, m, or s. Using default of $(duration $AGE_WARNING_SECONDS_DEFAULT)"
            echo $AGE_WARNING_SECONDS_DEFAULT
            ;;
    esac
    return 0
}

function human_readable_size {
    trace $FUNCNAME $@
    local bytes="$1"
    if [[ $bytes -eq 0 ]]; then
        echo "0B"
    elif [[ $bytes -lt 1024 ]]; then
        echo "${bytes}B"
    elif [[ $bytes -lt $((1024 * 1024)) ]]; then
        echo "$(($bytes / 1024))kB"
    elif [[ $bytes -lt $((1024 * 1024 * 1024)) ]]; then
        echo "$(($bytes / (1024 * 1024) ))MB"
    else
        echo "$bytes $((1024 * 1024 * 1024))" | awk '{printf "%.2fGB", $1/$2}'
    fi
}

function split {
    trace $FUNCNAME $@
    echo ${@//,/ }
}

function pool_lockfile {
    trace $FUNCNAME $@
    local poolname="$1"
    echo "$LOCK_PATH/zfs-mirror-$poolname.lock"
}

function get_lock {
    trace $FUNCNAME $@
    local lockfile="$1"
    logv "Trying to take lock: $lockfile"
    ( set -o noclobber; echo "$$" > "$lockfile") 2> /dev/null
    return $?
}

function have_lock {
    trace $FUNCNAME $@
    local lockfile="$1"
    [[ -f "$lockfile" ]] && [[ $(cat "$lockfile") = $$ ]]
    return $?
}

function release_lock {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local lockfile="$1"
    logv "Releasing lock $lockfile"
    if have_lock "$lockfile"; then
        rm -f "$lockfile"
    fi
    : $((DEPTH--))
    return 0
}

function cleanup {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local status="$1"
    release_lock $SRC_LOCKFILE
    release_lock $DEST_LOCKFILE
    : $((DEPTH--))
    return $status
}

function zfs_supports_multiple_snapshots {
    trace $FUNCNAME $@
    # Does the usage note for zfs snapshot include '...' at the end.
    $LOCAL_ZFS snapshot 2>&1 | $GREP -q -e '\.\.\.$'
    return $?
}

function get_source_filesystems {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local dests=$(split ${1:-".*"})
    local src_datasets=$($LOCAL_ZFS list -rH -o name $SRC)
    local fs
    for fs in $src_datasets; do
        local dest
        for dest in $dests; do
            if $LOCAL_ZFS get -Hp -o value $PROPERTY_SOURCE_LOCAL $PROPERTY_PREFIX:dest "$fs" | $GREP -q "$dest"; then
                logv "$fs configured as sync source"
                echo "$fs"
                break
            fi
        done
    done
    : $((DEPTH--))
}

function get_dest_pools {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local sources=$(split ${1:-""})
    local dests=$($LOCAL_ZFS get -Hp -o value $PROPERTY_SOURCE_LOCAL -t filesystem,volume -r zfs-mirror:dest $sources)
    local dest
    for dest in $(split $dests); do
        echo $dest
    done | sort -u
    : $((DEPTH--))
}

function dataset_exists {
    trace $FUNCNAME $@
    local host=$(echo "$1" | cut -d: -f1)
    local dataset=$(echo "$1" | cut -d: -f2)
    logv "Checking $dataset exists"
    if [[ "$host" == "localhost" ]]; then
        local zfs="$LOCAL_ZFS"
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    $zfs list "$dataset" >/dev/null 2>&1
    return $?
}

function snapshot_numbers {
    trace $FUNCNAME $@
    local zfs_cmd="$1"
    local dataset="$2"
    $zfs_cmd list -H -d 1 -r -o name -s name -t snapshot "$dataset" 2>  /dev/null | $GREP @${SNAPSHOT_PREFIX}_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n
}

function latest_snapshot {
    trace $FUNCNAME $@
    local host=$(echo "$1" | cut -d: -f1)
    local dataset=$(echo "$1" | cut -d: -f2)
    if [[ "$host" == "localhost" ]]; then
        local zfs="$LOCAL_ZFS"
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    local latest=$(snapshot_numbers "$zfs" "$dataset" | tail -n 1)
    echo -n ${latest:-0}
    logv "Latest snapshot of $1: ${latest:-0}"
}

function snapshot_created {
    trace $FUNCNAME $@
    local host=$(echo "$1" | cut -d: -f1)
    local snapshot=$(echo "$1" | cut -d: -f2)
    if [[ "$host" == "localhost" ]]; then
        local zfs="$LOCAL_ZFS"
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    local creation=$($zfs get -H -p -o value creation "$snapshot" 2>  /dev/null)
    case $creation in
        ''|*[!0-9]*) warn "Couldn't get creation time for $snapshot on $host (got $creation); returning 0"
        creation=0
        ;;
    esac
    echo -n ${creation}
    logv "Creation time of $1: ${creation}"
}

function get_dataset_destinations {
    trace $FUNCNAME $@
    local dataset="$1"
    split $($LOCAL_ZFS get -Hp -o value $PROPERTY_SOURCE_LOCAL $PROPERTY_PREFIX:dest "$dataset")
}

function host_has_cmd {
    trace $FUNCNAME $@
    local dest_host=$(echo "$1" | cut -d: -f1)
    local cmd="$2"
    if [[ "$dest_host" == "localhost" ]]; then
        $cmd > /dev/null 2>&1
    else
        logv "Connecting to remote host '$dest_host'"
        $SSH "$dest_host" $cmd > /dev/null 2>&1
    fi
    return $?
}

function get_pv_cmd {
    trace $FUNCNAME $@
    if $REALLY && ($PROGRESS || $LOG_SIZES_TO_FILE); then
        if [[ $# == 1 ]]; then
            local snapshot="$1"
            # Invoking zfs send to get the transfer size can take a few seconds, but
            # in practice it seems to warm some cache so the actual send take a few
            # seconds less, balancing it out.
            local size=$($LOCAL_ZFS send -nP "$snapshot" 2>&1 | tail -n 1|cut -f2)
        elif [[ $# == 2 ]]; then
            local snapshot1="$1"
            local snapshot2="$2"
            local size=$($LOCAL_ZFS send -nP -i "$snapshot1" "$snapshot2" 2>&1 | tail -n 1|cut -f2)
        else
            error "$FUNCNAME must be called with either one or two arguments, of the form 'dataset@snapshot' or '@snapshot1 dataset@snapshot2'"
        fi
        if $PROGRESS; then
            log "$(human_readable_size $size) to send (estimated)"
            local pv=""
            # Don't bother showing progress bar for < 5MB. The inaccuracy in the
            # estimate will probably be greater than the actual value.
            if [[ $size -ge 5*1024*1024 ]]; then
                pv="pv -s $size |"
            else
                logv "Not showing progress for transfer estimated as less than 5MB"
            fi
            echo $pv
        fi
        if $LOG_SIZES_TO_FILE; then
            echo -e "$(date)\t${snapshot1:-"-"}\t${snapshot2:-$snapshot}\t$size\t$(human_readable_size $size)" >> $SIZE_LOG_PATH
        fi
    fi
}

function zfs_try_send_incr {
    trace $FUNCNAME $@
    local dataset="$1"
    local src_snap_num="$2"
    local target_snap_num="$3"
    local dest_zfs="$4"
    local dest_pool="$5"
    local pv=$(get_pv_cmd @${SNAPSHOT_PREFIX}_$src_snap_num $dataset@${SNAPSHOT_PREFIX}_$target_snap_num)
    local error_msg=$(do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP -i @${SNAPSHOT_PREFIX}_$src_snap_num $dataset@${SNAPSHOT_PREFIX}_$target_snap_num | $pv $dest_zfs receive $ZFS_VERBOSE -ud $dest_pool 2>&1 || true")
    error_msg=${error_msg%%\\r}
    if [[ $error_msg != "" ]]; then
        if [[ $error_msg == "cannot receive incremental stream: invalid backup stream" ]]; then
            log "Error sending @${SNAPSHOT_PREFIX}_$src_snap_num $dataset@${SNAPSHOT_PREFIX}_$target_snap_num ($error_msg). Retrying:"
            error_msg=$(do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP -i @${SNAPSHOT_PREFIX}_$src_snap_num $dataset@${SNAPSHOT_PREFIX}_$target_snap_num | $pv $dest_zfs receive $ZFS_VERBOSE -ud $dest_pool 2>&1 || true")
            if [[ $error_msg != "" ]]; then
                warn "Error sending @${SNAPSHOT_PREFIX}_$src_snap_num $dataset@${SNAPSHOT_PREFIX}_$target_snap_num ($error_msg)"
            else
                log "Retry successful"
            fi
        else
            warn "Error sending @${SNAPSHOT_PREFIX}_$src_snap_num $dataset@${SNAPSHOT_PREFIX}_$target_snap_num ($error_msg)"
        fi
    fi
    echo $error_msg
}

function zfs_send_incr {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local dataset="$1"
    local dest_host=$(echo $2 | cut -d: -f1)
    local dest_pool=$(echo $2 | cut -d: -f2)
    local src_snap_num="$3"
    local target_snap_num="$4"
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$dest_host'"
        if $USE_TEMP_FILE; then
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host __zfs_receive_tmpfile \"$XZRECV zfs"
            dest_pool=$dest_pool'"'
        else
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host $XZRECV zfs"
        fi
    fi
    local error_msg=$(zfs_try_send_incr "$dataset" "$src_snap_num" "$target_snap_num" "$dest_zfs" "$dest_pool")
    if [[ $error_msg != "" ]]; then
        if [[ $error_msg == "cannot receive incremental stream: invalid backup stream" ]] && [[ $target_snap_num -gt $(( $src_snap_num + 1 )) ]]; then
            warn "Attempting to send intervening snapshots one-by-one:"
            local src_snapshots=$(snapshot_numbers "$LOCAL_ZFS" "$dataset")
            local prev="$src_snap_num"
            local snapshot
            for snapshot in $src_snapshots; do
                if [[ $snapshot -le $prev ]]; then
                    continue
                fi
                error_msg=$(zfs_try_send_incr "$dataset" $prev $snapshot "$dest_zfs" "$dest_pool")
                if [[ $error_msg != "" ]]; then
                    break
                fi
                prev=$snapshot
            done
        fi
    fi
    : $((DEPTH--))
    return 0
}

function zfs_send_new {
    trace $FUNCNAME $@
    : $((DEPTH++))
#$fs $DEST $new_snap
    local dest_host=$(echo $2 | cut -d: -f1)
    local dest_pool=$(echo $2 | cut -d: -f2)
    local destfs=$(echo -n "$1" | sed -e "s/^$SRC/$dest_pool/")
    local pv=$(get_pv_cmd $1@${SNAPSHOT_PREFIX}_$3)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
        local dest_zfs_cmd=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$dest_host'"
        if $USE_TEMP_FILE; then
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host __zfs_receive_tmpfile \"$XZRECV zfs"
            dest_pool=$dest_pool'"'
        else
            local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host $XZRECV zfs"
        fi
        local dest_zfs_cmd="$SSH $dest_host zfs"
    fi
    do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP $1@${SNAPSHOT_PREFIX}_$3 | $pv $dest_zfs receive -ud $dest_pool"
    do_conditionally "$dest_zfs_cmd set readonly=on $destfs"
    : $((DEPTH--))
    return 0
}

function expire_src_snaps {
    trace $FUNCNAME $@
    : $((DEPTH++))
    # NB: if a dest has been set for a dataset but has not completed even the
    # initial send, no snapshots will be destroyed as there's no way to know for
    # certain if a given snapshot is currently being sent by another instance of
    # the script.
    logv "Expiring old snapshots on $SRC"
    if [[ $(echo -e "foo\nbar"|$HEAD -n -1 2>/dev/null) != "foo" ]]; then
        warn "'$HEAD' doesn't support '-n -XX'; not expiring any snapshots on $SRC"
        return
    fi
    if [[ $KEEP_SRC -gt 1 ]]; then
        logv "Not considering the $KEEP_SRC most recent snapshots of each dataset for deletion"
    fi
    local latest_snap_num=$($LOCAL_ZFS get -pH -o value $PROPERTY_PREFIX:latest $SRC)
    local fs
    for fs in $@; do
        local latest_needed_snap_num=$latest_snap_num
        local dest
        for dest in $(get_dataset_destinations $fs); do
            local destfs=$(echo -n "$fs" | sed -e "s/^$SRC/$dest/")
            local latest_snap_on_dest=$(latest_snapshot $destfs)
            if [[ $latest_snap_on_dest == "0" ]]; then
                warn "Can't find any snapshots of $fs on $dest; either this dataset has never been synchronised, or there was a connection problem. Not expiring any snapshots."
            fi
            if [[ $latest_snap_on_dest -lt $latest_needed_snap_num ]]; then
                latest_needed_snap_num=$latest_snap_on_dest
            fi
        done
        local snap_num
        for snap_num in $(snapshot_numbers "$LOCAL_ZFS" "$fs" | $HEAD -n -$KEEP_SRC); do
            if [[ $snap_num -lt $latest_needed_snap_num ]]; then
                logv "Snapshot unneeded: $fs@${SNAPSHOT_PREFIX}_$snap_num"
                do_conditionally "$LOCAL_ZFS destroy $ZFS_VERBOSE $fs@${SNAPSHOT_PREFIX}_$snap_num"
            else
                logv "Snapshot needed: $fs@${SNAPSHOT_PREFIX}_$snap_num"
            fi
        done
    done
    : $((DEPTH--))
    return 0
}

function expire_dest_snaps {
    trace $FUNCNAME $@
    : $((DEPTH++))
    # $DEST $source_filesystems
    logv "Expiring old snapshots on $1"
    if [[ $(echo -e "foo\nbar"|$HEAD -n -1 2>/dev/null) != "foo" ]]; then
        warn "'$HEAD' doesn't support '-n -XX'; not expiring any snapshots on $1"
        return
    fi
    local dest_host=$(echo $1 | cut -d: -f1)
    local dest_pool=$(echo $1 | cut -d: -f2)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
        local dest_zpool=$LOCAL_ZPOOL
    else
        logv "Connecting to remote host '$dest_host'"
        local dest_zfs="$SSH $dest_host zfs"
        local dest_zpool="$SSH $dest_host zpool"
    fi
    shift
    local srcfs
    for srcfs in $@; do
        destfs=$(echo -n "$srcfs" | sed -e "s/$SRC/$dest_pool/")
        logv "Expiring snapshots on $dest_host:$destfs"
        local snap_num
        for snap_num in $(snapshot_numbers "$dest_zfs" "$destfs" | $HEAD -n -$KEEP_DEST); do
            do_conditionally "$dest_zfs destroy $ZFS_VERBOSE $destfs@${SNAPSHOT_PREFIX}_$snap_num"
        done
    done
    local threshold=95
    local success=true
    local cap=$($dest_zpool list -H -o capacity $dest_pool) || success=$?
    if [[ ! $success ]]; then
        # Strictly this check isn't necessary, but the previous check for this
        # pool's existence used 'zfs' rather than 'zpool', so this serves as a
        # sanity check that 'zpool' is available.
        warn "Couldn't find pool ${dest_host}:$dest_pool"
    elif [[ $(echo $cap | cut -d% -f1) -gt $threshold ]]; then
        warn "Destination capacity over $threshold% ($cap) after snapshot expiration"
    fi
    : $((DEPTH--))
    return 0
}

function age_report {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local src="$1"
    local dest="$2"
    log "Checking for snapshots from $src on $dest older than $(duration $AGE_WARNING_SECONDS):"
    if [[ -f $(pool_lockfile $src-to-$dest) ]]; then
        log "There appears to be a synchronisation from $src to $dest currently in progress"
    fi
    if ! which $DATE_COMMAND > /dev/null 2>&1; then
        error "'date' not found; can't check snapshot ages"
    fi
    logv "Source filesystems:"
    local source_filesystems=$(get_source_filesystems $dest)
    local max_name_len=0
    local fs
    for fs in $source_filesystems; do
        if [[ ${#fs} -gt $max_name_len ]]; then
            max_name_len=${#fs}
        fi
    done
    for fs in $source_filesystems; do
        local pad_len=$((max_name_len - ${#fs}))
        local padding=$(printf "%*.s" $pad_len)
        local latest_snap_num=$(latest_snapshot $(echo -n "$fs" | sed -e "s/^$src/$dest/"))
        local latest_snap=${SNAPSHOT_PREFIX}_${latest_snap_num}
        if [[ $latest_snap_num -le 0 ]]; then
            warn "Can't find any snapshots of $fs on $dest; either this dataset has never been synchronised, or there was a connection problem"
            created=0
        else
            created=$(snapshot_created $(echo -n "$fs" | sed -e "s/^$src/$dest/")@$latest_snap)
        fi
        local time_now=$($DATE_COMMAND +%s)
        local age=$(($time_now - $created))
        if [[ $age -gt $AGE_WARNING_SECONDS ]]; then
            warn "Latest snapshot of $fs on $dest:$padding $latest_snap, created $($DATE_COMMAND -d @$created) ($(duration $age) old)"
        else
            log "Latest snapshot of $fs on $dest:$padding $latest_snap, created $($DATE_COMMAND -d @$created) ($(duration $age) old)"
        fi
    done
    : $((DEPTH--))
}

function mirror {
    trace $FUNCNAME $@
    : $((DEPTH++))
    local src=$1
    local dest=$2
    # It's worth waiting for the source lock to become available, as it's only held
    # while creating and expiring snapshots, which typically doesn't take very long.
    local wait_start_time=$($DATE_COMMAND +%s)
    local wait_time=0
    while [[ -e "$SRC_LOCKFILE" ]] && ( [[ $wait_time -lt 60 ]] || $WAIT_FOR_LOCK ); do
        log "Couldn't get lock for $SRC (after $(duration $wait_time)); waiting 10 seconds"
        sleep 10
        wait_time=$(($($DATE_COMMAND +%s) - $wait_start_time))
    done
    if get_lock $SRC_LOCKFILE; then
        # It's probably not worth waiting for the per-destination lock, since it
        # could be held for a long time (ie. there's a sync in progress), so we
        # only wait if explicitly instructed.
        if $WAIT_FOR_LOCK; then
            wait_start_time=$($DATE_COMMAND +%s)
            wait_time=0
            while [[ -e "$DEST_LOCKFILE" ]]; do
                log "Couldn't get lock for $DEST_LOCKFILE (after $(duration $wait_time)); waiting 10 seconds"
                sleep 10
                wait_time=$(($($DATE_COMMAND +%s) - $wait_start_time))
            done
        fi
        if get_lock $DEST_LOCKFILE; then
            local old_snap=$($LOCAL_ZFS get -pH -o value $PROPERTY_PREFIX:latest $src)
            if [[ $old_snap == '-' ]]; then
                do_conditionally "$LOCAL_ZFS set $PROPERTY_PREFIX:latest=0 $src"
                old_snap=0
            fi
            local new_snap=$(($old_snap + 1))

            # define what snapshots we want to create
            logv "Source filesystems:"
            local source_filesystems=$(get_source_filesystems $dest)
            local new_snapshots=""
            local fs
            for fs in $source_filesystems; do
                new_snapshots+=" $fs@${SNAPSHOT_PREFIX}_$new_snap"
            done

            # Second task: create new snapshots
            if [[ $source_filesystems != "" ]]; then
                do_conditionally "$LOCAL_ZFS set $PROPERTY_PREFIX:latest=$new_snap $src"
                if zfs_supports_multiple_snapshots; then
                    do_conditionally "$LOCAL_ZFS snapshot $new_snapshots"
                else
                    warn "This version of zfs does not support making multiple snapshots in a single invocation; snapshot creation will not be atomic."
                    local snap
                    for snap in $new_snapshots; do
                        do_conditionally "$LOCAL_ZFS snapshot $snap"
                    done
                fi
            else
                warn "No source filesytems defined for destination $dest"
                release_lock $SRC_LOCKFILE
                release_lock $DEST_LOCKFILE
                : $((DEPTH--))
                return $ERR_NO_SOURCES_DEFINED
            fi
            release_lock $SRC_LOCKFILE

            # Third task: sync new snapshots
            if $COMPRESS && host_has_cmd localhost "xz --version" && host_has_cmd $dest "xzcat --version"; then
                XZSEND="xz |"
                XZRECV="xzcat \|"
            fi
            for fs in $source_filesystems; do
                old_snap=$(latest_snapshot $(echo -n "$fs" | sed -e "s/^$src/$dest/"))
                local success=true
                if [[ $old_snap -gt 0 ]]; then
                    if ! dataset_exists localhost:$fs@${SNAPSHOT_PREFIX}_$old_snap; then
                        # This implies something is seriously wrong, so bail
                        # out even if there are other jobs to do.
                        error "Snapshot $fs@${SNAPSHOT_PREFIX}_$old_snap missing from $src" $ERR_SRC_SNAP_MISSING
                    fi
                    zfs_send_incr $fs $dest $old_snap $new_snap || success=$?
                else
                    zfs_send_new $fs $dest $new_snap || success=$?
                fi
                if [[ ! $success ]]; then
                    release_lock $DEST_LOCKFILE
                    warn "Failed to send $fs@$new_snap to $dest; giving up"
                    : $((DEPTH--))
                    return $ERR_COULDNT_SEND
                fi
            done
            # Fourth task: expire unneeded snapshots on source
            if get_lock $SRC_LOCKFILE; then
                # It's not critical that this done now - for one thing, in all
                # probability whatever process is holding the lock will do this
                # snapshot expiration anyway - so don't bother waiting for it to
                # become available.
                expire_src_snaps $source_filesystems
                release_lock $SRC_LOCKFILE
            fi
            # Fifth task: expire unwanted snapshots on dest
            expire_dest_snaps $dest $source_filesystems
            release_lock $DEST_LOCKFILE
        else # We got the source lock, but not the dest lock
            release_lock $SRC_LOCKFILE
            log "Couldn't get lock for $src to $dest; giving up"
            : $((DEPTH--))
            return 1
        fi
    else
        # Either the source pool lock has been held for a while, or we got
        # really unlucky and another process grabbed it in between checking for
        # it, and trying to take it.
        log "Couldn't get lock for $src after $wait_time seconds; giving up"
        : $((DEPTH--))
        return 1
    fi
    : $((DEPTH--))
    return 0
}

function display_help {
cat <<EOF
Usage: zfs-mirror [options] [source pool(s)] [destination pool(s)]

Source should be specified in the form "pool[,pool...]".
  Default is all pools found on the local system.

Destination should be specified in the form "hostname:pool[,hostname:pool...]"
  Default is all destinations configured for any datasets on the specified
  source pool.

Available options:
  -a <age>
     Age report warning threshold: '-R' will warn for snapshots older than <age>.
       Must be a number, optionally suffixed with d, h, m, or s.
       Default is $AGE_WARNING_SECONDS_DEFAULT ($(duration $AGE_WARNING_SECONDS_DEFAULT))
  -b <number>
     Limit send rate to <number>kBps.
  -c <option>
     Colour: must be one of 'auto', 'never', 'always'.
       Default is 'auto': colourise logging if output destination is a terminal.
  -D Dedup: use deduplicated zfs send streams, as per 'zfs send -D ...'
  -h Help: display this usage note.
  -k <number>
     Keep <number> old snapshots on each destination dataset.
  -l Log each transfer along with its estimated size in TSV format to
       "/var/log/zfs-mirror-est-send-sizes-<source>-to-<destination>.log"
  -n Dry run: don't make any changes, but print the commands that would have
       been executed.
  -o <option>
     Output destination: must be one of 'auto', 'syslog', 'tty'
       Default is 'auto': log to stderr if it is a terminal, else to syslog.
  -p Display a progress bar for transfers. The total transfer size is an
       estimate, so the progress display can be somewhat innacurate; hence,
       transfers estimated at < 5MB will not show a progress bar.
  -R Report on the age of existing backups: for each dataset to mirror, produce
       a warning if the most recent snapshot is older than a configurable
       threshold (see '-a').
  -r Recursive: Send child datasets if the destination property is inherited,
       rather than requiring explicit configuration per-dataset.
  -t Use a temporary file on the destination rather than piping directly from
       'zfs send' to 'zfs receive'.
  -v Verbose: May be specified up to four times to increase the output
       verbosity. By default only warnings and errors are printed.
  -w Wait for lock: If unable to lock the source/dest pools, wait indefinitely
       rather than giving up after 60s. This uses polling, so it is unlikely
       that multiple waiting processes will proceed in FIFO order.
  -z Use xz if available to compress transfers.
EOF
}

if [[ -t 2 ]]; then
    # stderr is a terminal
    LOG_TO_STDERR=true
fi

while getopts "a:b:c:Dhk:lno:pRrtvwz" opt; do
    case $opt in
        a)
            AGE_WARNING=$OPTARG
            ;;
        b)
            if [[ -x $(which $PV) ]]; then
                BWLIMIT="$PV -qL ${OPTARG}k |"
            else
                PV_NOT_FOUND=true
            fi
            ;;
        c)
            COLOUR=$OPTARG
            ;;
        D)
            ZFS_SEND_DEDUP="-D"
            ;;
        h)
            display_help
            exit 0
            ;;
        k)
            # Sanity check: don't allow this to be set to less than 1
            if [[ $OPTARG -ge 1 ]]; then
                KEEP_DEST=$OPTARG
            else
                KEEP_DEST=1
            fi
            ;;
        l)
            LOG_SIZES_TO_FILE=true
            ;;
        n)
            REALLY=false
            ;;
        o)
            case $OPTARG in
                auto)
                    ;;
                syslog)
                    LOG_TO_STDERR=false
                    ;;
                tty)
                    LOG_TO_STDERR=true
                    ;;
                *)
                    INVALID_OUTPUT_DEST=true
                    ;;
            esac
            ;;
        p)
            if [[ -x $(which $PV) ]]; then
                PROGRESS=true
            else
                PV_NOT_FOUND=true
                PROGRESS=false
            fi
            ;;
        R)
            AGE_REPORTING=true
            ;;
        r)
            PROPERTY_SOURCE_LOCAL=""
            ;;
        t)
            USE_TEMP_FILE=true
            ;;
        v)
            : $((VERBOSE++))
            ;;
        w)
            WAIT_FOR_LOCK=true
            ;;
        z)
            COMPRESS=true
            ;;
        *)
            display_help 1>&2
            exit $ERR_INVALID_ARGUMENT
            ;;

    esac
done
shift $((OPTIND - 1))

case $COLOUR in
    never)
        COLOUR=false
        ;;
    always)
        COLOUR=true
        ;;
    auto)
        if $LOG_TO_STDERR && [[ -t 2 ]]; then
            COLOUR=true
        else
            COLOUR=false
        fi
        ;;
    *)
        INVALID_COLOUR=true
        if $LOG_TO_STDERR && [[ -t 2 ]]; then
            COLOUR=true
        else
            COLOUR=false
        fi
        ;;
esac

if $COLOUR; then
    COL_GREEN="\e[32m"
    COL_GREY="\e[1;30m"
    COL_YELLOW="\e[1;33m"
    COL_RED="\e[31m"
    COL_END="\e[0m"
else
    COL_GREEN=""
    COL_GREY=""
    COL_YELLOW=""
    COL_RED=""
    COL_END=""
fi

if [[ -n ${PV_NOT_FOUND+x} ]]; then
    warn "Progress display and bandwidth limiting require 'pv', which was not found in \$PATH"
fi

if [[ -n ${INVALID_COLOUR+x} ]]; then
    warn "Argument to -c must be 'auto', 'never', or 'always'. Using auto."
fi

if [[ -n ${INVALID_OUTPUT_DEST+x} ]]; then
    warn "Argument to -o must be 'auto', 'syslog', or 'tty'. Using auto."
fi
for command in $LOCAL_ZFS $LOCAL_ZPOOL $GREP; do
    if [[ ! -x $(which $command) ]]; then
        error "'$command' not found"
    fi
done

if [[ $VERBOSE -ge 4 ]]; then
    ZFS_VERBOSE="-v"
fi

if [[ -w "/var/run" ]]; then
    LOCK_PATH="/var/run"
else
    LOCK_PATH="$HOME"
fi

if [[ -e /usr/gnu/bin/date ]]; then
    DATE_COMMAND="/usr/gnu/bin/date"
else
    DATE_COMMAND="date"
fi
if ! which $DATE_COMMAND > /dev/null 2>&1; then
    error "'date' not found"
    DATE=""
elif ! $DATE_COMMAND --rfc-3339=ns > /dev/null 2>&1; then
    warn "'date' doesn't support '--rfc-3339'; trace timestamps will only have second precision"
    DATE="$DATE_COMMAND +%Y/%m/%d/%H.%M.%S"
else
    DATE="$DATE_COMMAND --rfc-3339=ns"
fi

if [[ -n ${AGE_WARNING+x} ]]; then
    AGE_WARNING_SECONDS=$(parse_duration $AGE_WARNING)
else
    AGE_WARNING_SECONDS=$AGE_WARNING_SECONDS_DEFAULT
fi

case $# in
    0)
        SOURCE_POOLS=$($LOCAL_ZPOOL list -H -o name)
        ;;
    1)
        if [[ $1 == *:* ]]; then
            SOURCE_POOLS=$($LOCAL_ZPOOL list -H -o name)
            DESTS=$1
        else
            SOURCE_POOLS=$1
        fi
        ;;
    2)
        if [[ $1 != *:* ]] && [[ $2 == *:* ]]; then
            SOURCE_POOLS=$1
            DESTS=$2
        else
            error "Invalid source/dest pool combination ($1/$2)\nSee '$0 -h' for more information" $ERR_INVALID_ARGUMENT
        fi
        ;;
    *)
        error "Invalid source/dest pool combination ($*)\nSee '$0 -h' for more information" $ERR_INVALID_ARGUMENT
        ;;
esac

for SRC in $(split $SOURCE_POOLS); do
    if ! dataset_exists localhost:$SRC; then
        error "Couldn't find source pool '$SRC'" $ERR_SRC_POOL_MISSING
    fi

    DESTS=${DESTS:-$(get_dest_pools $SRC)}

    SRC_LOCKFILE=$(pool_lockfile $SRC)
    DEST_LOCKFILE=""

    trap 'cleanup $?' INT TERM EXIT

    for DEST in $(split $DESTS); do
        DEST_LOCKFILE=$(pool_lockfile $SRC-to-$DEST)

        if [[ $(echo $DEST | cut -d: -f1) != "localhost" ]] && [[ ! -x $(which $SSH) ]]; then
            error "'$SSH' not found"
        fi
        if ! dataset_exists $DEST; then
            warn "Couldn't find dest pool $DEST"
            STATUS=$ERR_DEST_POOL_MISSING
            continue
        fi

        if $LOG_SIZES_TO_FILE; then
            # Change the colon to an underscore for ease of transporting to Windows.
            SIZE_LOG_PATH="/var/log/zfs-mirror-est-send-sizes-${SRC}-to-${DEST//:/_}.log"
        fi

        if $AGE_REPORTING; then
            age_report $SRC $DEST
        else
            mirror $SRC $DEST || STATUS=$?
        fi
    done
done

# If there were any errors not quite severe enough to terminate the process
# entirely, $STATUS holds the error code for the *most recent* failure.
exit ${STATUS:-0}
