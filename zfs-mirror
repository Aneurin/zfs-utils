#!/bin/bash

# Configuration:
#
# For each dataset to synchronise, set the property "zfs-mirror:dest" locally on
# that dataset, to values of the form "hostname:pool[,hostname:pool...]"
#
# The script will set the property "zfs-mirror:latest" on the root dataset; this
# shouldn't be manually changed.

set -o nounset
set -e

# Ugly perhaps, but this is the simplest way not to have to worry about $PATH on
# different systems
PATH=/usr/gnu/bin:/usr/local/bin:/opt/bin:/sbin:/usr/sbin:/bin:/usr/bin:$PATH

LOCAL_ZFS=zfs
LOCAL_ZPOOL=zpool
GREP=grep
HEAD=head
SSH=ssh
TRICKLE=trickle
PV=pv

VERBOSE=0
REALLY=1
PROGRESS=0
BWLIMIT=""
KEEP_DEST=10
KEEP_SRC=2
ZFS_SEND_DEDUP=""
LOG_TO_STDERR=false
COLOUR="auto"
COMPRESS=false
XZSEND=""
XZRECV=""

PROPERTY_PREFIX=zfs-mirror
SNAPSHOT_PREFIX=zfs-mirror

ERR_SRC_POOL_MISSING=64   # Source pool not given or not found
ERR_DEST_POOL_MISSING=65  # Destination pool not found
ERR_NO_SOURCES_DEFINED=66 # No source filesystems are configured for the given destination
ERR_SRC_SNAP_MISSING=67   # The source filesystem doesn't have the counterpart to the destination's latest snapshot
ERR_COULDNT_SEND=68       # There was a problem synchronising the snapshot from the source to the destination

if [[ -t 2 ]]; then
    # stderr is a terminal
    LOG_TO_STDERR=true
fi

while getopts "b:c:k:npvDo:z" opt; do
    case $opt in
        b)
            if [[ -x $(which $TRICKLE) ]]; then
                BWLIMIT="$TRICKLE -s -u $OPTARG"
            else
                TRICKLE_NOT_FOUND=true
            fi
            ;;
        c)
            COLOUR=$OPTARG
            ;;
        k)
            # Sanity check: don't allow this to be set to less than 1
            if [[ $OPTARG -ge 1 ]]; then
                KEEP_DEST=$OPTARG
            else
                KEEP_DEST=1
            fi
            ;;
        n)
            REALLY=0
            ;;
        p)
            if [[ -x $(which $PV) ]]; then
                PROGRESS=1
            else
                PV_NOT_FOUND=true
                PROGRESS=0
            fi
            ;;
        v)
            : $((VERBOSE++))
            ;;
        D)
            ZFS_SEND_DEDUP="-D"
            ;;
        o)
            case $OPTARG in
                auto)
                    ;;
                syslog)
                    LOG_TO_STDERR=false
                    ;;
                tty)
                    LOG_TO_STDERR=true
                    ;;
                *)
                    INVALID_OUTPUT_DEST=true
                    ;;
            esac
            ;;
        z)
            COMPRESS=true
            ;;
    esac
done
shift $((OPTIND - 1))

case $COLOUR in
    never)
        COLOUR=false
        ;;
    always)
        COLOUR=true
        ;;
    auto)
        if $LOG_TO_STDERR && [[ -t 2 ]]; then
            COLOUR=true
        else
            COLOUR=false
        fi
        ;;
    *)
        INVALID_COLOUR=true
        if $LOG_TO_STDERR && [[ -t 2 ]]; then
            COLOUR=true
        else
            COLOUR=false
        fi
        ;;
esac

if $COLOUR; then
    COL_GREEN="\e[32m"
    COL_GREY="\e[1;30m"
    COL_YELLOW="\e[1;33m"
    COL_RED="\e[31m"
    COL_END="\e[0m"
else
    COL_GREEN=""
    COL_GREY=""
    COL_YELLOW=""
    COL_RED=""
    COL_END=""
fi

function out {
    if $LOG_TO_STDERR; then
        cat >&2
    else
        logger -t zfs-mirror\[$$\]
    fi
}

function warn {
    echo -e "[$COL_YELLOW""Warn: $COL_END]" $@ | out
}

function error {
    echo -e "[$COL_RED""Error:$COL_END]" $1 | out
    local status=${2:-1}
    exit $status
}

if [[ -n ${TRICKLE_NOT_FOUND+x} ]]; then
    error "Bandwidth limiting requires 'trickle', which was not found in \$PATH"
fi

if [[ -n ${PV_NOT_FOUND+x} ]]; then
    warn "Progress display requires 'pv', which was not found in \$PATH"
fi

if [[ -n ${INVALID_COLOUR+x} ]]; then
    warn "Argument to -c must be 'auto', 'never', or 'always'. Using auto."
fi

if [[ -n ${INVALID_OUTPUT_DEST+x} ]]; then
    warn "Argument to -o must be 'auto', 'syslog', or 'tty'. Using auto."
fi
for command in $LOCAL_ZFS $LOCAL_ZPOOL $GREP; do
    if [[ ! -x $(which $command) ]]; then
        error "'$command' not found"
    fi
done

if [[ $# -eq 0 ]]; then
    error "You must specify a source pool" $ERR_SRC_POOL_MISSING
fi
SRC=$1
DEST=${2:-'localhost:backup'}

ZFS_VERBOSE=""
if [[ $VERBOSE -ge 4 ]]; then
    ZFS_VERBOSE="-v"
fi

if [[ $(id -u) -eq 0 ]]; then
    LOCK_PATH=/var/run
else
    LOCK_PATH=$HOME
fi
GLOBAL_LOCKFILE=$LOCK_PATH/zfs-mirror.lock
DEST_LOCKFILE=$LOCK_PATH/zfs-mirror-$DEST.lock

if [[ $VERBOSE -ge 3 ]]; then
    if [[ -e /usr/gnu/bin/date ]]; then
        DATE="/usr/gnu/bin/date"
    else
        DATE="date"
    fi
    if ! which $DATE > /dev/null 2>&1; then
        warn "'date' not found; trace output will lack timestamps"
        DATE=""
    elif ! $DATE --rfc-3339=ns > /dev/null 2>&1; then
        warn "'date' doesn't support '--rfc-3339'; trace timestamps will only have second precision"
        DATE="$DATE +%Y/%m/%d/%H.%M.%S"
    else
        DATE="$DATE --rfc-3339=ns"
    fi
fi

DEPTH=0
function trace {
    if [[ $VERBOSE -ge 3 ]]; then
        printf "[$COL_GREY""Trace:$COL_END] $COL_GREY""[$($DATE)]$COL_END%*s%s\n" $((DEPTH * 4)) " " "$*" | out
    fi
}

function log {
    if [[ $VERBOSE -ge 1 ]]; then
        echo -e "[$COL_GREEN""Info: $COL_END]" $@ | out
    fi
}

function logv {
    if [[ $VERBOSE -ge 2 ]]; then
        echo "[Debug:]" $@ | out
    fi
}

function do_conditionally {
    trace $FUNCNAME $@

    if [[ $REALLY == 1 ]]; then
        log "Running: $@"
        eval $@
    else
        log "Would run: $@"
    fi
}

function get_lock {
    trace $FUNCNAME $@
    logv "Trying to take lock: $1"
    ( set -o noclobber; echo "$$" > "$1") 2> /dev/null
    return $?
}

function have_lock {
    trace $FUNCNAME $@
    [ -f $1 ] && [ $(cat $1) = $$ ]
    return $?
}

function release_lock {
    trace $FUNCNAME $@
    : $((DEPTH++))
    logv "Releasing lock $1"
    if have_lock $1; then
        rm -f $1
    fi
    : $((DEPTH--))
    return 0
}

function cleanup {
    trace $FUNCNAME $@
    : $((DEPTH++))
    release_lock $GLOBAL_LOCKFILE
    release_lock $DEST_LOCKFILE
    : $((DEPTH--))
    return $1
}

function zfs_supports_multiple_snapshots {
    trace $FUNCNAME $@
    # Does the usage note for zfs snapshot include '...' at the end.
    $LOCAL_ZFS snapshot 2>&1 | $GREP -q -e '\.\.\.$'
    return $?
}

function get_source_filesystems {
    trace $FUNCNAME $@
    local dest=${1:-""}
    for fs in $($LOCAL_ZFS list -rH -o name $SRC); do
        if $LOCAL_ZFS get -Hp -o value -s local $PROPERTY_PREFIX:dest $fs | $GREP -q ""$dest; then
            logv "$fs configured as sync source"
            echo $fs
        fi
    done
}

function dataset_exists {
    trace $FUNCNAME $@
    local host=$(echo $1 | cut -d: -f1)
    local dataset=$(echo $1 | cut -d: -f2)
    logv "Checking $dataset exists"
    if [[ $host == "localhost" ]]; then
        local zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    $zfs list $dataset >/dev/null 2>&1
    return $?
}

function latest_snapshot {
    trace $FUNCNAME $@
    local host=$(echo $1 | cut -d: -f1)
    local dataset=$(echo $1 | cut -d: -f2)
    if [[ $host == "localhost" ]]; then
        local zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$host'"
        local zfs="$SSH $host zfs"
    fi
    local latest=$($zfs list -H -d 1 -r -o name -s name -t snapshot $dataset 2>  /dev/null | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n | tail -n 1)
    echo -n ${latest:-0}
    logv "Latest snapshot of $1: ${latest:-0}"
}

function get_destinations {
    trace $FUNCNAME $@
    local OLDIFS=$IFS
    IFS=','
    for dest in $($LOCAL_ZFS get -Hp -o value -s local $PROPERTY_PREFIX:dest $1); do
        echo -n " $dest"
    done
    IFS=$OLDIFS
}

function host_has_cmd {
    trace $FUNCNAME $@
    local dest_host=$(echo $1 | cut -d: -f1)
    if [[ $dest_host == "localhost" ]]; then
        $2 > /dev/null 2>&1
    else
        logv "Connecting to remote host '$dest_host'"
        $SSH $dest_host $2 > /dev/null 2>&1
    fi
    return $?
}

function zfs_try_send_incr {
    # $1 source dataset
    # $2 source snapshot number
    # $3 destination snapshot number
    # $4 destination zfs command
    # $5 destination pool
    trace $FUNCNAME $@
    local pv=""
    if [[ $REALLY == 1 ]] && [[ $PROGRESS == 1 ]]; then
        # Invoking zfs send to get the transfer size can take a few seconds, but
        # in practice it seems to warm some cache so the actual send take a few
        # seconds less, balancing it out.
        local size=$($LOCAL_ZFS send -nPi @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 2>&1 | tail -n 1|cut -f2)
        # Don't bother showing progress bar for < 5MB. The inaccuracy in the
        # estimate will probably be greater than the actual value.
        if [[ $size -ge 5*1024*1024 ]]; then
            pv="pv -s $size |"
        fi
    fi
    local error=$(do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP -i @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 | $pv $4 receive $ZFS_VERBOSE -ud $5 2>&1 || true")
    error=${error%%\\r}
    if [[ $error != "" ]]; then
        if [[ $error == "cannot receive incremental stream: invalid backup stream" ]]; then
            log "Error sending @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 ($error). Retrying:"
            error=$(do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP -i @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 | $pv $4 receive $ZFS_VERBOSE -ud $5 2>&1 || true")
            if [[ $error != "" ]]; then
                warn "Error sending @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 ($error)"
            else
                log "Retry successful"
            fi
        else
            warn "Error sending @"$SNAPSHOT_PREFIX"_$2 $1@"$SNAPSHOT_PREFIX"_$3 ($error)"
        fi
    fi
    echo $error
}

function zfs_send_incr {
    trace $FUNCNAME $@
    : $((DEPTH++))
#$fs $DEST $old_snap $new_snap
    local dest_host=$(echo $2 | cut -d: -f1)
    local dest_pool=$(echo $2 | cut -d: -f2)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$dest_host'"
        local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host $XZRECV zfs"
    fi
    local error=$(zfs_try_send_incr $1 $3 $4 "$dest_zfs" "$dest_pool")
    if [[ $error != "" ]]; then
        if [[ $error == "cannot receive incremental stream: invalid backup stream" ]] && [[ $4 -gt $(( $3 + 1 )) ]]; then
            warn "Attempting to send intervening snapshots one-by-one:"
            local intervening_snapshots=$($LOCAL_ZFS list -H -d 1 -r -o name -s name -t snapshot $1 2> /dev/null | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n)
            local prev=$3
            for snapshot in $intervening_snapshots; do
                if [[ $snapshot -le $prev ]]; then
                    continue
                fi
                error=$(zfs_try_send_incr $1 $prev $snapshot "$dest_zfs" "$dest_pool")
                if [[ $error != "" ]]; then
                    break
                fi
                prev=$snapshot
            done
        fi
    fi
    : $((DEPTH--))
    return 0
}

function zfs_send_new {
    trace $FUNCNAME $@
    : $((DEPTH++))
#$fs $DEST $new_snap
    local dest_host=$(echo $2 | cut -d: -f1)
    local dest_pool=$(echo $2 | cut -d: -f2)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
    else
        logv "Connecting to remote host '$dest_host'"
        local dest_zfs="$XZSEND $BWLIMIT $SSH $dest_host $XZRECV zfs"
    fi
    do_conditionally "$LOCAL_ZFS send $ZFS_VERBOSE $ZFS_SEND_DEDUP $1@"$SNAPSHOT_PREFIX"_$3 | $dest_zfs receive -ud $dest_pool"
    local destfs=$(echo -n "$1" | sed -e "s/^$SRC/$dest_pool/")
    do_conditionally "$dest_zfs set readonly=on $destfs"
    : $((DEPTH--))
    return 0
}

function expire_src_snaps {
    trace $FUNCNAME $@
    : $((DEPTH++))
    # NB: if a dest has been set for a dataset but has not completed even the
    # initial send, no snapshots will be destroyed as there's no way to know for
    # certain if a given snapshot is currently being sent by another instance of
    # the script.
    logv "Expiring old snapshots on $SRC"
    if [[ $(echo -e "foo\nbar"|$HEAD -n -1 2>/dev/null) != "foo" ]]; then
        warn "'$HEAD' doesn't support '-n -XX'; not expiring any snapshots on $1"
        return
    fi
    if [[ $KEEP_SRC -gt 1 ]]; then
        logv "Not considering the $KEEP_SRC most recent snapshots of each dataset for deletion"
    fi
    local latest_snap_num=$($LOCAL_ZFS get -pH -o value $PROPERTY_PREFIX:latest $SRC)
    for fs in $@; do
        local latest_needed_snap_num=$latest_snap_num
        for dest in $(get_destinations $fs); do
            local destfs=$(echo -n "$fs" | sed -e "s/^$SRC/$dest/")
            local latest_snap_on_dest=$(latest_snapshot $destfs)
            if [[ $latest_snap_on_dest == "0" ]]; then
                warn "Can't find any snapshots of $fs on $dest; either this dataset has never been synchronised, or there was a connection problem. Not expiring any snapshots."
            fi
            if [[ $latest_snap_on_dest -lt $latest_needed_snap_num ]]; then
                latest_needed_snap_num=$latest_snap_on_dest
            fi
        done
        for snap_num in $($LOCAL_ZFS list -H -d 1 -r -o name -s name -t snapshot $fs | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n | $HEAD -n -$KEEP_SRC); do
            if [[ $snap_num -lt $latest_needed_snap_num ]]; then
                logv "Snapshot unneeded: $fs@"$SNAPSHOT_PREFIX"_$snap_num"
                do_conditionally "$LOCAL_ZFS destroy $ZFS_VERBOSE $fs@"$SNAPSHOT_PREFIX"_$snap_num"
            else
                logv "Snapshot needed: $fs@"$SNAPSHOT_PREFIX"_$snap_num"
            fi
        done
    done
    : $((DEPTH--))
    return 0
}

function expire_dest_snaps {
    trace $FUNCNAME $@
    : $((DEPTH++))
    logv "Expiring old snapshots on $1"
    if [[ $(echo -e "foo\nbar"|$HEAD -n -1 2>/dev/null) != "foo" ]]; then
        warn "'$HEAD' doesn't support '-n -XX'; not expiring any snapshots on $1"
        return
    fi
    local dest_host=$(echo $1 | cut -d: -f1)
    local dest_pool=$(echo $1 | cut -d: -f2)
    if [[ $dest_host == "localhost" ]]; then
        local dest_zfs=$LOCAL_ZFS
        local dest_zpool=$LOCAL_ZPOOL
    else
        logv "Connecting to remote host '$dest_host'"
        local dest_zfs="$SSH $dest_host zfs"
        local dest_zpool="$SSH $dest_host zpool"
    fi
    shift
    for srcfs in $@; do
        destfs=$(echo -n "$srcfs" | sed -e "s/$SRC/$dest_pool/")
        logv "Expiring snapshots on $dest_host:$destfs"
        for snap_num in $($dest_zfs list -H -d 1 -r -o name -s name -t snapshot $destfs 2>  /dev/null | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//" | sort -n | $HEAD -n -$KEEP_DEST); do
            do_conditionally "$dest_zfs destroy $ZFS_VERBOSE $destfs@"$SNAPSHOT_PREFIX"_$snap_num"
        done
    done
    local threshold=95
    local cap=$($dest_zpool list -H -o capacity $dest_pool)
    if [[ ! $? ]]; then
        # Strictly this check isn't necessary, but the previous check for this
        # pool's existence used 'zfs' rather than 'zpool', so this serves as a
        # sanity check that 'zpool' is available.
        warn "Couldn't find pool $DEST"
    elif [[ $(echo $cap | cut -d% -f1) -gt $threshold ]]; then
        warn "Destination capacity over $threshold% ($cap) after snapshot expiration"
    fi
    : $((DEPTH--))
    return 0
}

#function expire_src_snaps {
#    # This might be better done entirely differently: determine the last
#    # snapshot number for which a full set of replicas exist, and destroy any
#    # older. IE:
#    # Starting at the current snapshot number, for each configured source fs,
#    # check if each configure dest has that snapshot, and decrement snapshot
#    # numbers until that's the case, then destroy any older than that
#    local all_source_filesystems=$(get_source_filesystems)
#    for fs in $all_source_filesystems; do
#        for snap_num in $($LOCAL_ZFS list -H -d 1 -r -o name -t snapshot $fs | $GREP @"$SNAPSHOT_PREFIX"_ | sed -e "s/.*@$SNAPSHOT_PREFIX\_//"); do
#            local next_snap=$fs@"$SNAPSHOT_PREFIX"_$((snap_num + 1))
#            local snapshot_needed="false"
#            # If unneeded - source and all configured destinations have this snapshot's successor
#            # This is currently too conservative - if the snapshot is so out of
#            # date that the destination no longer has it, then we mark it as
#            # still needed
#            if dataset_exists localhost:$next_snap; then
#                for dest in $(get_destinations $fs); do
#                    local dest_next_snap=$(echo -n "$next_snap" | sed -e "s/^$SRC/$dest/")
#                    if ! dataset_exists $dest_next_snap; then
#                        snapshot_needed="true"
#                        break
#                    fi
#                done
#            else
#                snapshot_needed="true"
#            fi
#            if [[ $snapshot_needed == "true" ]]; then
#                logv "Snapshot needed: $fs@"$SNAPSHOT_PREFIX"_$snap_num"
#            elif [[ $snapshot_needed == "false" ]]; then
#                logv "Snapshot unneeded: $fs@"$SNAPSHOT_PREFIX"_$snap_num"
#                do_conditionally "$LOCAL_ZFS destroy $ZFS_VERBOSE $fs@"$SNAPSHOT_PREFIX"_$snap_num"
#            else
#                echo "This can't happen: ($snapshot_needed)" >&2
#                exit 1
#            fi
#        done
#    done
#}

trap 'cleanup $?' INT TERM EXIT

# It's worth waiting for the global lock to become available, as it's not
# typically held for very long
WAITTIME=0
while [[ -e "$GLOBAL_LOCKFILE" ]] && [[ $WAITTIME -lt 60 ]]; do
    log "Couldn't get global lock (after $WAITTIME seconds); waiting 10 seconds"
    : $((WAITTIME += 10))
    sleep 10
done

if get_lock $GLOBAL_LOCKFILE; then
    # It's probably not worth waiting for the per-destination lock, since it
    # could be held for a long time (ie. there's a sync in progress)
    if ! dataset_exists localhost:$SRC; then
        error "Couldn't find source pool '$SRC'" $ERR_SRC_POOL_MISSING
    fi
    if get_lock $DEST_LOCKFILE; then
        if [[ $(echo $DEST | cut -d: -f1) != "localhost" ]] && [[ ! -x $(which $SSH) ]]; then
            error "'$SSH' not found"
        fi
        if ! dataset_exists $DEST; then
            error "Couldn't find pool $DEST" $ERR_DEST_POOL_MISSING
        fi
        old_snap=$($LOCAL_ZFS get -pH -o value $PROPERTY_PREFIX:latest $SRC)
        new_snap=$(($old_snap + 1))

        # define what snapshots we want to create
        logv "Source filesystems:"
        source_filesystems=$(get_source_filesystems $DEST)
        new_snapshots=""
        for fs in $source_filesystems; do
            new_snapshots+=" $fs@"$SNAPSHOT_PREFIX"_$new_snap"
        done

        # Second task: create new snapshots
        if [[ $source_filesystems != "" ]]; then
            do_conditionally "$LOCAL_ZFS set $PROPERTY_PREFIX:latest=$new_snap $SRC"
            if zfs_supports_multiple_snapshots; then
                do_conditionally "$LOCAL_ZFS snapshot $new_snapshots"
            else
                warn "This version of zfs does not support making multiple snapshots in a single invocation; snapshot creation will not be atomic."
                for snap in $new_snapshots; do
                    do_conditionally "$LOCAL_ZFS snapshot $snap"
                done
            fi
        else
            error "No source filesytems defined for destination $DEST" $ERR_NO_SOURCES_DEFINED
        fi
        release_lock $GLOBAL_LOCKFILE

        # Third task: sync new snapshots
        if $COMPRESS && host_has_cmd localhost "xz --version" && host_has_cmd $DEST "xzcat --version"; then
            XZSEND="xz |"
            XZRECV="xzcat \|"
        fi
        for fs in $source_filesystems; do
            old_snap=$(latest_snapshot $(echo -n "$fs" | sed -e "s/^$SRC/$DEST/"))
            if [[ $old_snap -gt 0 ]]; then
                if ! dataset_exists localhost:$fs@"$SNAPSHOT_PREFIX"_$old_snap; then
                    error "Snapshot $fs@"$SNAPSHOT_PREFIX"_$old_snap missing from $SRC" $ERR_SRC_SNAP_MISSING
                fi
                zfs_send_incr $fs $DEST $old_snap $new_snap
            else
                zfs_send_new $fs $DEST $new_snap
            fi
            if [[ ! $? ]]; then
                error "Failed to send $fs@$new_snap to $DEST; giving up" $ERR_COULDNT_SEND
            fi
        done
        # Fourth task: expire unneeded snapshots on source
        if get_lock $GLOBAL_LOCKFILE; then
            # It's not critical that this done now - for one thing, in all
            # probability whatever process is holding the lock will do this
            # snapshot expiration anyway - so don't bother waiting for it to
            # become available.
            expire_src_snaps $source_filesystems
        fi
        # Fifth task: expire unwanted snapshots on dest
        expire_dest_snaps $DEST $source_filesystems
    else
        log "Couldn't get lock for $DEST; giving up"
        exit 1
    fi
else
    log "Couldn't get global zfs-mirror lock after $WAITTIME seconds; giving up"
    exit 1
fi
